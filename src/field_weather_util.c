#include "global.h"
#include "field_weather.h"
#include "overworld.h"
#include "constants/weather.h"
#include "constants/map_groups.h"

// External helpers provided elsewhere
u8 GetCurrentHour(void);
u16 Random(void);
static bool8 IsNightTime(void);

// ---------------------------------------------------------------------------
// Hourly roll (000–999) and digit extraction
// ---------------------------------------------------------------------------

static void UpdateWeatherRollIfNeeded(void)
{
    u8 hour = GetCurrentHour(); // RTC or playtime hour

    if (hour != gSaveBlock2Ptr->weatherRollHour)
    {
        gSaveBlock2Ptr->weatherRoll = Random() % 1000; // 000–999
        gSaveBlock2Ptr->weatherRollHour = hour;
    }
}

static void GetWeatherDigits(u16 roll, u8 *x, u8 *y, u8 *z)
{
    *x = roll / 100;        // hundreds
    *y = (roll / 10) % 10;  // tens
    *z = roll % 10;         // ones
}

// ---------------------------------------------------------------------------
// Region code (X/Y/Z/C/I/S/V) and digit-selection formula
// ---------------------------------------------------------------------------

enum {
    REGION_X,
    REGION_Y,
    REGION_Z,
    REGION_C,
    REGION_I,
    REGION_S,
    REGION_V,
    REGION_COUNT
};

// NOTE: Adjust these ranges to match how your weather_ids.inc / weather_tables.inc
// assign indices to Z-, Y-, X-, C-, I-, S-, and V-series clusters.
static u8 GetRegionForWeatherId(u8 weatherId)
{
    // Example layout:
    //  0–9   : Z-series (Johto South)
    // 10–19  : Y-series (Johto North)
    // 20–29  : X-series (Johto West)
    // 30–39  : C-series (Kanto Coastal)
    // 40–49  : I-series (Kanto Inland)
    // 50–59  : S-series (Sevii)
    // 60+    : V-series / microclimates / special
    if (weatherId <= 9)
        return REGION_Z;
    else if (weatherId <= 19)
        return REGION_Y;
    else if (weatherId <= 29)
        return REGION_X;
    else if (weatherId <= 39)
        return REGION_C;
    else if (weatherId <= 49)
        return REGION_I;
    else if (weatherId <= 59)
        return REGION_S;
    else
        return REGION_V;
}

static u8 GetWeatherSlotForRegion(u8 region)
{
    u8 x, y, z;
    GetWeatherDigits(gSaveBlock2Ptr->weatherRoll, &x, &y, &z);

    switch (region)
    {
    case REGION_X: return x;                 // hundreds digit
    case REGION_Y: return y;                 // tens digit
    case REGION_Z: return z;                 // ones digit

    case REGION_C: return (x + y) % 10;      // coastal
    case REGION_I: return (x + z) % 10;      // inland
    case REGION_S: return (y + z) % 10;      // Sevii
    case REGION_V: return (x + y + z) % 10;  // microclimates / specials
    }

    return 0; // fallback
}

// ---------------------------------------------------------------------------
// Weather ID lookup (map → cluster/weatherId)
// ---------------------------------------------------------------------------

// Matches the structure generated by weather_ids.inc
struct MapWeatherIdEntry {
    u8 mapGroup;
    u8 mapNum;
    u8 weatherId;   // cluster index: Z0, X4, C2, etc.
};

// Auto-generated from weather_ids.inc
extern const struct MapWeatherIdEntry gMapWeatherIds[];

// Auto-generated from weather_tables.inc
// Each entry points to a 10-slot table like WeatherTable_Z0, WeatherTable_X4, etc.
extern const u8 *const gWeatherTables[];

static u8 GetWeatherIdForCurrentMap(void)
{
    u8 group = gSaveBlock1Ptr->location.mapGroup;
    u8 num   = gSaveBlock1Ptr->location.mapNum;

    int i;
    for (i = 0; gMapWeatherIds[i].mapGroup != 0xFF; i++)
    {
        if (gMapWeatherIds[i].mapGroup == group &&
            gMapWeatherIds[i].mapNum   == num)
            return gMapWeatherIds[i].weatherId;
    }

    // Default to first Johto South cluster (Z0) or whatever you prefer.
    return 0;
}

// ---------------------------------------------------------------------------
// Weather table lookup (cluster/weatherId → table → slot)
// ---------------------------------------------------------------------------

static u8 GetWeatherFromTable(u8 weatherId, u8 slot)
{
    const u8 *table = gWeatherTables[weatherId];
    return table[slot];
}

// ---------------------------------------------------------------------------
// Main climate logic: map → cluster → region → slot → weather
// ---------------------------------------------------------------------------

static u8 GetRawWeatherForMap(void)
{
    u8 weatherId;
    u8 region;
    u8 slot;

    // Interiors should never use climate logic unless explicitly forced
    if (!IsMapTypeOutdoors(gMapHeader.mapType))
        return WEATHER_NONE;

    // 1. Map → cluster/weatherId
    weatherId = GetWeatherIdForCurrentMap();

    // 2. Cluster/weatherId → region code (X/Y/Z/C/I/S/V)
    region = GetRegionForWeatherId(weatherId);

    // 3. Region code + hourly roll → slot 0–9
    slot = GetWeatherSlotForRegion(region);

    // 4. Cluster table + slot → final raw weather
    return GetWeatherFromTable(weatherId, slot);
}

static u8 ApplyTimeOfDayCorrections(u8 weather)
{
    if (IsNightTime())
    {
        if (weather == WEATHER_SUNNY || weather == WEATHER_EXTREME_SUN)
            return WEATHER_NONE; // or WEATHER_CLEAR if you prefer
    }

    return weather;
}

static u8 FinalizeWeather(u8 weather)
{
    if (!IsMapTypeOutdoors(gMapHeader.mapType))
        return WEATHER_NONE;

    if (weather == WEATHER_RAIN)
    {
        // 20–35% chance of thunderstorm
        if (Random() % 100 < 25)
            return WEATHER_RAIN_THUNDERSTORM;
    }

    return weather;
}

u8 DetermineCurrentWeather(void)
{
    u8 raw;
    u8 corrected;

    UpdateWeatherRollIfNeeded();

    raw = GetRawWeatherForMap();
    corrected = ApplyTimeOfDayCorrections(raw);

    return FinalizeWeather(corrected);
}

// ========================
// SAVED WEATHER PLUMBING
// ========================

static u8 TranslateWeatherNum(u8 weather);
static void UpdateRainCounter(u8 newWeather, u8 oldWeather);

void SetSavedWeather(u32 weather)
{
    u8 oldWeather = gSaveBlock1Ptr->weather;
    gSaveBlock1Ptr->weather = TranslateWeatherNum(weather);
    UpdateRainCounter(gSaveBlock1Ptr->weather, oldWeather);
}

u8 GetSav1Weather(void)
{
    return gSaveBlock1Ptr->weather;
}

// CLIMATE ENTRY POINT FROM MAP HEADER
void SetSavedWeatherFromCurrMapHeader(void)
{
    u8 oldWeather = gSaveBlock1Ptr->weather;
    gSaveBlock1Ptr->weather = DetermineCurrentWeather();
    UpdateRainCounter(gSaveBlock1Ptr->weather, oldWeather);
}

void SetWeather(u32 weather)
{
    SetSavedWeather(weather);
    SetNextWeather(GetSav1Weather());
}

void SetWeather_Unused(u32 weather)
{
    SetSavedWeather(weather);
    SetCurrentAndNextWeather(GetSav1Weather());
}

void DoCurrentWeather(void)
{
    u8 weather = GetSav1Weather();
    SetNextWeather(weather);
}

void ResumePausedWeather(void)
{
    u8 weather = GetSav1Weather();
    SetCurrentAndNextWeather(weather);
}

// Vanilla Emerald-style cycles kept for compatibility if you still use them
static const u8 sWeatherCycleRoute119[] = {
    WEATHER_SUNNY,
    WEATHER_RAIN,
    WEATHER_RAIN_THUNDERSTORM,
    WEATHER_RAIN,
};

static const u8 sWeatherCycleRoute123[] = {
    WEATHER_SUNNY,
    WEATHER_SUNNY,
    WEATHER_RAIN,
    WEATHER_SUNNY,
};

static u8 TranslateWeatherNum(u8 weather)
{
    switch (weather)
    {
    case WEATHER_NONE:               return WEATHER_NONE;
    case WEATHER_SUNNY_CLOUDS:       return WEATHER_SUNNY_CLOUDS;
    case WEATHER_SUNNY:              return WEATHER_SUNNY;
    case WEATHER_RAIN:               return WEATHER_RAIN;
    case WEATHER_SNOW:               return WEATHER_SNOW;
    case WEATHER_RAIN_THUNDERSTORM:  return WEATHER_RAIN_THUNDERSTORM;
    case WEATHER_FOG_HORIZONTAL:     return WEATHER_FOG_HORIZONTAL;
    case WEATHER_VOLCANIC_ASH:       return WEATHER_VOLCANIC_ASH;
    case WEATHER_SANDSTORM:          return WEATHER_SANDSTORM;
    case WEATHER_FOG_DIAGONAL:       return WEATHER_FOG_DIAGONAL;
    case WEATHER_UNDERWATER:         return WEATHER_UNDERWATER;
    case WEATHER_SHADE:              return WEATHER_SHADE;
    case WEATHER_DROUGHT:            return WEATHER_DROUGHT;
    case WEATHER_DOWNPOUR:           return WEATHER_DOWNPOUR;
    case WEATHER_UNDERWATER_BUBBLES: return WEATHER_UNDERWATER_BUBBLES;
    case WEATHER_ROUTE119_CYCLE:     return sWeatherCycleRoute119[gSaveBlock1Ptr->weatherCycleStage];
    case WEATHER_ROUTE123_CYCLE:     return sWeatherCycleRoute123[gSaveBlock1Ptr->weatherCycleStage];
    default:                         return WEATHER_NONE;
    }
}

void UpdateWeatherPerDay(u16 increment)
{
    u16 weatherStage = gSaveBlock1Ptr->weatherCycleStage + increment;
    weatherStage %= 4;
    gSaveBlock1Ptr->weatherCycleStage = weatherStage;
}

static void UpdateRainCounter(u8 newWeather, u8 oldWeather)
{
    if (newWeather != oldWeather
        && (newWeather == WEATHER_RAIN || newWeather == WEATHER_RAIN_THUNDERSTORM))
        IncrementGameStat(GAME_STAT_GOT_RAINED_ON);
}

// ============================================================
// DAY/NIGHT TINT SYSTEM
// ============================================================

static bool8 IsNightTime(void)
{
    u8 hour = GetCurrentHour();
    return (hour >= 18 || hour < 6);
}


